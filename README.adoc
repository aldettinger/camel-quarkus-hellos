= Camel-Quarkus Demo

== How to Prepare the Demo

[source,shell]
----
# Start a cluster, for instance:
crc start -b crc-linux-1.8.0-amd64/crc_libvirt_4.3.8.crcbundle

# Login
oc login -u kubeadmin -p <PASSWORD> https://api.crc.testing:6443

# Clone the git demo project locally
cd camel-quarkus-demo
git clone https://github.com/aldettinger/camel-quarkus-hellos.git camel-quarkus-hellos

# Deploy hellos project to the crc cluster
cd camel-hellos
mvnu clean package -Dquarkus.kubernetes.deploy=true

# Check that the jvm mode pod is working
curl -X PUT -d '{ "room" : { "temperature" : 35}}' http://hello-camel-quarkus-jvm-mode-default.apps-crc.testing/hello-camel-quarkus-jvm-mode --resolve hello-camel-quarkus-jvm-mode-default.apps-crc.testing:$(crc ip)
curl http://hello-camel-quarkus-jvm-mode-default.apps-crc.testing/hello-camel-quarkus-jvm-mode --resolve hello-camel-quarkus-jvm-mode-default.apps-crc.testing:$(crc ip)

# Check that the native mode pod is working
# ERROR logs from pdfont are excluded as the log level is set to FATAL
curl -X PUT -d '{ "room" : { "temperature" : 20}}' http://hello-camel-quarkus-native-mode-default.apps-crc.testing/hello-camel-quarkus-native-mode --resolve hello-camel-quarkus-native-mode-default.apps-crc.testing:$(crc ip)
curl http://hello-camel-quarkus-native-mode-default.apps-crc.testing/hello-camel-quarkus-native-mode --resolve hello-camel-quarkus-native-mode-default.apps-crc.testing:$(crc ip)

!!! STEPS ABOVE ARE NOT NEEDED AT THIS STAGE, START HERE !!!

# Launch eclipse and delete the 'my-quarkus' project from eclipse if any
# Open terminator
rm -fr ~/dev/demos/camel-quarkus-demo/my-quarkus-project/
rm ~/dev/demos/camel-quarkus-demo/file.pdf
cd ~/dev/demos/camel-quarkus-demo/
# Split window horizontally
# Tune the zoom (CTRL + scroll 6x)
# Zoom in eclipse editor (CTRL/SHIFT/+ 3 times so that we have ~90 chars per line)
# Put the README.adoc demo script on another screen if any (could be good to show that in vim or gedit)
----

== How to Run the Demo

[source,shell]
----
# Speech: Welcome, Software Engineer, Camel contributor
# Speech: Getting started on camel-quarkus, key concepts
# Speech: Quarkus = Kubernetes native Java stack
# Speech: Camel = 300+ technologies/framework and many eips (=proven integration recipes)
# Speech: Typical usage of camel = consume / eip / produce

# Pre-requisistes
java -version
mvnu -version
native-image --version (gcc, glibc, zlib)

# Create project skeleton: Keep all default values
mvnu io.quarkus:quarkus-maven-plugin:1.6.1.Final:create

# Speech: quarkus extensions = Make a technology or framework working with quarkus
cd my-quarkus-project
mvnu quarkus:list-extensions
mvnu quarkus:add-extensions -Dextensions=platform-http,jsonpath,pdf

# Import in eclipse: ~/dev/demos/camel-quarkus-demo/my-quarkus-project

Create MyRouteBuilder class:
public class MyRouteBuilder extends RouteBuilder {
    @Override
    public void configure() {
        from("platform-http:/hello").setBody(constant("Hello From Camel Quarkus !"));
    }
}

# Speech: Dev mode = Continuous feedback loop
mvnu quarkus:dev

# Speech: Watch changes and update in the blink of an eye
# Kill the watch as it will pollute startup memory in next steps
watch http :8080/hello

# Add MyRouteBuilderTest:
import static io.restassured.RestAssured.given;

@QuarkusTest
public class MyRouteBuilderTest {
    @Test
    void getHelloShouldReturnHttp200(){
        given().when().get("/hello").then().statusCode(200);
    }
}

# Build it in JVM Mode
mvnu clean install

# Speech: All inclusive disk size ~= runner + lib + java (for java, you'll need at least modules)
# "lib/modules" size ~= openjre11-alpine-image-size - alpine-3.12-image-size (open jre 11.0.9 docker image is based on alpine 3.12)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner.jar target/lib ${JAVA_HOME}/lib/modules

# Speech: Camel boot time / Quarkus boot time
java -jar target/my-quarkus-project-1.0-SNAPSHOT-runner.jar

# Speech: Resident Set Size = everything in RAM in KiB ~= shared library + stack + heap
ps -o rss,cmd $(pgrep -f quarkus)

# Proves that it run
http :8080/hello

# Then show native mode, 3 minutes speech while native compilation occurs:
# JVM mode ~= Optimize boot time and mem usage by moving some framework initialization tasks from runtime to build time
              Load configuration at build time, find annotated classes at build time, remove unused bean at build time

# Native   ~= Optimize with a different technique using GraalVM Native Image static compilation at build time
              Execute static initializer at build time, remove unused method/fields at build time, remove jit compiler
              Build an executable containing the snapshot of the application startup memory

# JVM vs Native ~= It's different optimizations adapted to different scenarios.
  JVM ~= quick build/debug, fast startup, more memory, a single long running jvm with good throughput and response time
  Native ~= long build/debug, instant startup, less memory, some short running jvms with throughput by scaling/density
mvnu package -P native

# Speech: Just enough of application code / third party libs / jdk)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner*
# Speech: Instant startup
target/my-quarkus-project-1.0-SNAPSHOT-runner
# Then rss mem
ps -o rss,cmd $(pgrep -f quarkus)
# And finally show it working
http :8080/hello

# Add default message:
# setBody(simple("{{camel.default-msg}}")). # in route
# camel.default-msg = COLD # in src/main/resources/applications.properties
mvnu quarkus:dev
http :8080/hello

# Add some jsonpath logic in route:
#    @Override
#    public void configure() throws Exception {
#        from("platform-http:/hello").
#            choice().when(jsonpath("$.room[?(@.temperature > 30)]")).
#                setBody(constant("It's HOT")).
#            otherwise().
#                setBody(simple("It's {{camel.default-msg}}")).
#            end();
#    }
watch http :8080/hello <<< '{room: {temperature: 30}}'

# Finally, add pdf generation
# .to("pdf:create?fontSize=26").convertBodyTo(byte[].class); // convert needed till CAMEL-15267 camel 3.4.1 and 3.5.0
http :8080/hello <<< '{room : {temperature : 40}}' > test.pdf
firefox test.pdf

# Then run compare.sh
cd ..
# Speech: compare SB/JVM/NATIVE, roughly estimate the time to service the first request with consecutive http requests
camel-hellos/compare.sh

# Speech: This is basic example for a demo but now you should have a better idea of what is camel-quarkus
# Speech: In a nutshell, it's all about lightweight pattern based integrations running in the cloud

# Then I should end up with thanks, ask for contributions, give links, and perharps talk about camel project family ?

# End for now
----------------------------------------------------------------------------------------------------------------------
# In a future demo, then show the resulting densification in a crc cluster with quotas mem ? cpu ? (ideally all hellos project but could be only jvm vs native)
# Launch some requests to scale pods, we would expect native to exhibit a better densification
At first, it's possible to set replicas = 20 and show the time it takes in OpenShift DeploymentConfig view

Raw notes for demo/improvements:
Interest of native mode:
JIT vs AOT => faster startup since code is already pre-compiled into efficient machine code
No need to include infrastructure to load and optimize code at run time => less memory
static analysis to embed what's used from the JDK, 3rd party libs and JVM code
vscode to have auto completion ?
compare.sh compare disk/boot/rss BEFORE the first request, so do the same during the demo
Show quarkus live reload ? (update the dev and show result directly in the cluster)
Does quarkus really improve disk size in jvm mode only ? integrate an unused class and check size for instance ? APPARENTLY IT SHOULD
An interest of fast startup is that it improve disposability (help to scale, move process to another node...)
On a public cloud, densification allows the use of smaller instances to run an application so reduce costs
cloud provider portability => need kubernetes to abstract cloud specific services like object bucket storage => then we still need a framework to use those services => Quarkus
Quarkus streamlines the registration process by detecting and auto-registering as many of your code’s reflection candidates as possible (interest of quarkus on top of graalvm)
JVM mode is simpler, going native could introduce additional steps (eg add some dependencies to indexer)
Check how to simply deploy on openshift (https://developers.redhat.com/blog/2020/04/24/ramp-up-on-quarkus-a-kubernetes-native-java-framework/)
Quarkus, even in JVM mode, moves some typical framework init phase from runtime to build time (load/parse config),
Find annotated class, attempt to load class to enable/disable features, build its model of the world)
An advantage of quarkus jvm mode vs native, is that you have some startup/mem/disk optimization with a quick build phase
Quarkus-native applications bring a much smaller memory footprint at the expense of throughput, which is now handled through scaling and elasticity—the same way you find in Kubernetes
It also brings faster startup speeds at the expense of dynamic runtime behavior, which is now unnecessary overhead in immutable deployment architectures—again, like you find in Kubernetes
GraalVM operates with a closed world assumption. It analyzes the call tree and removes all the classes/methods/fields that are not used directly.
One size does not fit all! Quarkus gives you the option to scale up in JVM mode if you need a single instance with a larger heap, or scale out in Native mode if you need more, lighter-weight instances

TODO: I'll present before Justin that will show some EIPs pattern
TODO: I'll present after Omar that will show how to build and deploy camel quarkus routes with tekton and knative

TODO: Parler trop vite au début, re-travailler le milieu (peut-être des slides)
      Trop évasif au début
      Il manque une transition pour camel_hellos
      Pas un benchmark

When I boot offline, then start crc, I get the issue below:
ERRO Failed to query DNS from host: lookup api.crc.testing on [::1]:53: read udp [::1]:36955->[::1]:53: read: connection refused
Maybe an app listening on port 53 ? Only when started without network ?
Then, I replug the network, start vpn and I can start crc again
----

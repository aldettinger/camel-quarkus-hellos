= Camel-Quarkus Demo

== How to Prepare the Demo

[source,shell]
----
# Start a cluster, for instance:
crc start -b crc-linux-1.8.0-amd64/crc_libvirt_4.3.8.crcbundle

# Login
oc login -u kubeadmin -p <PASSWORD> https://api.crc.testing:6443

# Clone the git demo project locally
cd camel-quarkus-demo
git clone https://github.com/aldettinger/camel-quarkus-hellos.git camel-quarkus-hellos

# Deploy hellos project to the crc cluster
cd camel-hellos
mvnu clean package -Dquarkus.kubernetes.deploy=true

# Check that the jvm mode pod is working
curl -X PUT -d '{ "room" : { "temperature" : 35}}' http://hello-camel-quarkus-jvm-mode-default.apps-crc.testing/hello-camel-quarkus-jvm-mode --resolve hello-camel-quarkus-jvm-mode-default.apps-crc.testing:$(crc ip)
curl http://hello-camel-quarkus-jvm-mode-default.apps-crc.testing/hello-camel-quarkus-jvm-mode --resolve hello-camel-quarkus-jvm-mode-default.apps-crc.testing:$(crc ip)

# Check that the native mode pod is working
# ERROR logs from pdfont are excluded as the log level is set to FATAL
curl -X PUT -d '{ "room" : { "temperature" : 20}}' http://hello-camel-quarkus-native-mode-default.apps-crc.testing/hello-camel-quarkus-native-mode --resolve hello-camel-quarkus-native-mode-default.apps-crc.testing:$(crc ip)
curl http://hello-camel-quarkus-native-mode-default.apps-crc.testing/hello-camel-quarkus-native-mode --resolve hello-camel-quarkus-native-mode-default.apps-crc.testing:$(crc ip)

!!! STEPS ABOVE ARE NOT NEEDED AT THIS STAGE, START HERE !!!

# Delete my-quarkus project from eclipse if any
# Open terminator
rm -fr ~/dev/demos/camel-quarkus-demo/my-quarkus-project/
cd ~/dev/demos/camel-quarkus-demo/
Split window horizontally #And in both terminal do:
----

== How to Run the Demo

[source,shell]
----
mvnu io.quarkus:quarkus-maven-plugin:1.5.1.Final:create
# Keep all default values

# Show extensions
cd my-quarkus-project
mvnu quarkus:list-extensions
mvnu quarkus:add-extensions -Dextensions=platform-http,jsonpath,pdf

# Import in eclipse: ~/dev/demos/camel-quarkus-demo/my-quarkus-project

Create MyRouteBuilder class:
public class MyRouteBuilder extends RouteBuilder {
    @Override
    public void configure() {
        // \ud83d\udc2b => camel
        // \ud83d\ude03 => grinning face
        from("platform-http:/hello").setBody(constant("Hello From Camel Quarkus !"));
    }
}

# Show the dev mode, update message and curl again
mvnu quarkus:dev

# Get the first body, change, and show update in the blink of an eye
watch http :8080/hello

# Add MyRouteBuilderTest:
import static io.restassured.RestAssured.given;

@QuarkusTest
public class MyRouteBuilderTest {
    @Test
    void getHelloShouldReturnHttp200(){
        given().when().get("/hello").then().statusCode(200);
    }
}

# Display the size of the runner + lib + java (lib/modules is good estimation of jre size)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner.jar target/lib ${JAVA_HOME}/lib/modules

# Show the jvm mode from the command line
java -jar target/my-quarkus-project-1.0-SNAPSHOT-runner.jar

# Notice the camel boot time
# Define Resident Set Size (everything in RAM ~= shared library + stack + heap) and display usage in KiB
ps -o rss,cmd $(pgrep -f quarkus)

# Proves that it run but ONLY after having checked initial memory
http :8080/hello

# Then show native mode, 3 minutes speech while native compilation occurs
# JVM mode ~= Moves some typical framework init phase from runtime to build time
              Load/parse config, find annotated class, load class to enable/disable features
# Native   ~= GraalVM Native Image, ahead of time compilation, static code analysis, remove unused class/method/fields
              Remove jit, execute static initializer, take snapshot of startup application memory
mvnu package -P native

# Show size first (just enough of application code / third party libs / jdk)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner*
# Then boot time
target/my-quarkus-project-1.0-SNAPSHOT-runner
# Then rss mem
ps -o rss,cmd $(pgrep -f quarkus)
# And finally show it working
http :8080/hello

# Add default message:
# setBody(simple("{{camel.default-msg}}")). # in route
# camel.default-msg = COLD # in src/main/resources/applications.properties
http :8080/hello

# Add some jsonpath logic in route:
#    @Override
#    public void configure() throws Exception {
#        from("platform-http:/hello").
#            choice().when(jsonpath("$.room[?(@.temperature > 30)]")).
#                setBody(constant("It's HOT")).
#            otherwise().
#                setBody(simple("It's {{camel.default-msg}}")).
#            end();
#    }
http :8080/hello <<< '{room: {temperature: 30}}'

# Finally, add pdf generation
# .to("pdf:create?fontSize=26").convertBodyTo(byte[].class);
http :8080/hello <<< '{room : {temperature : 40}}' > test.pdf
firefox test.pdf

# Then run the demo comparing camel-hellos project, e.g a summary like
# Implement standalone, and perharps spring boot
						boot	rss		size
 standalone			1s		1Mo		1Mo
 spring-boot			2s		2Mo		2Mo
 quarkus-jvm-mode		3s		3Mo		3Mo
 quarkus-native-mode	4s		4Mo		4Mo
camel-hellos/compare.sh

# Then show the resulting densification in a crc cluster with quotas mem ? cpu ? (ideally all hellos project but could be only jvm vs native)
# Launch some requests to scale pods, we would expect native to exhibit a better densification
At first, it's possible to set replicas = 20 and show the time it takes in OpenShift DeploymentConfig view

Raw notes for demo/improvements:
Interest of native mode:
JIT vs AOT => faster startup since code is already pre-compiled into efficient machine code
No need to include infrastructure to load and optimize code at run time => less memory
static analysis to embed what's used from the JDK, 3rd party libs and JVM code
Tool "hey" to push a burden like "hey url"
vscode to have auto completion ?
init project from quarkus.io ?
compare.sh compare disk/boot/rss BEFORE the first request, so do the same during the demo
Show quarkus live reload ? (update the dev and show result directly in the cluster)
Does quarkus really improve disk size in jvm mode only ? integrate an unused class and check size for instance ?
Does quarkus really improve memory size in jvm mode only ? how ?
Finish the demo explaining how could help with camel-quarkus project
An interest of fast startup is that it improve disposability (help to scale, move process to another node...)
On a public cloud, densification allows the use of smaller instances to run an application so reduce costs
cloud provider portability => need kubernetes to abstract cloud specific services like object bucket storage => than we still need a framework to use those services => Quarkus
Quarkus streamlines the registration process by detecting and auto-registering as many of your code’s reflection candidates as possible (interest of quarkus on top of graalvm)
JVM mode is simpler, going native could introduce additional steps (eg add some dependencies to indexer)
Check how to simply deploy on openshift (https://developers.redhat.com/blog/2020/04/24/ramp-up-on-quarkus-a-kubernetes-native-java-framework/)
Quarkus, even in JVM mode, moves some typical framework init phase from runtime to build time (load/parse config,
find annotated class, attempt to load class to enable/disable features, build its model of the world)
An advantage of quarkus jvm mode vs native, is that you have some startup/mem/disk optimization with a quick build phase
Quarkus-native applications bring a much smaller memory footprint at the expense of throughput, which is now handled through scaling and elasticity—the same way you find in Kubernetes
It also brings faster startup speeds at the expense of dynamic runtime behavior, which is now unnecessary overhead in immutable deployment architectures—again, like you find in Kubernetes
GraalVM operates with a closed world assumption. It analyzes the call tree and removes all the classes/methods/fields that are not used directly.
One size does not fit all! Quarkus gives you the option to scale up in JVM mode if you need a single instance with a larger heap, or scale out in Native mode if you need more, lighter-weight instances

When I boot offline, then start crc, I get the issue below:
ERRO Failed to query DNS from host: lookup api.crc.testing on [::1]:53: read udp [::1]:36955->[::1]:53: read: connection refused
Maybe an app listening on port 53 ? Only when started without network ?
Then, I replug the network, start vpn and I can start crc again
----
